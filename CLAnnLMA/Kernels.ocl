#define TRUE 1
#define FALSE 0
#define DEBUG TRUE

__kernel void arrayMemSet(__global CLNetDataType * restrict array, uint elements, CLNetDataType value)
{
	const uint id = get_global_id(0);
	if (id < elements) {
		array[id] = value;
	}
}


//Activations
//MARK:BIAS
//__kernel void activationLinear(__global CLNetDataType * restrict matrix, uint rows, uint columns)
//{
//	uint x = get_global_id(0);
//	uint y = get_global_id(1);
//
//	//MARK:BIAS
//	if (y == columns - 1) {
//		matrix[x * columns + y] = 1;
//	}
//}

__kernel void activationSigmoid(__global CLNetDataType * restrict matrix, uint rows, uint columns)
{
	uint x = get_global_id(0);
	uint y = get_global_id(1);

	if (x < rows && y < columns) {
		matrix[x * columns + y] = 1 / (1 + exp(- matrix[x * columns + y]));

		//MARK:BIAS
		if (y == columns - 1) {
			matrix[x * columns + y] = 1;
		}
	}
}

__kernel void activationTansig(__global CLNetDataType * restrict matrix, uint rows, uint columns)
{
    uint x = get_global_id(0);
    uint y = get_global_id(1);

	if (x < rows && y < columns) {
		matrix[x * columns + y] = 2 / (1 + exp(-2 * matrix[x * columns + y])) - 1;

		//MARK:BIAS
		if (y == columns - 1) {
			matrix[x * columns + y] = 1;
		}
	}
}

__kernel void activationRadbas(__global CLNetDataType * restrict matrix, uint rows, uint columns)
{
	uint x = get_global_id(0);
	uint y = get_global_id(1);

	if (x < rows && y < columns) {
		CLNetDataType val = matrix[x * columns + y];
		matrix[x * columns + y] = exp(-(val * val));

		//MARK: BIAS
		if (y == columns - 1) {
			matrix[x * columns + y] = 1;
		}
	}
}


//Chi Squared
static void inline reduceInline(uint localId, __global CLNetDataType * restrict partialSums, __local CLNetDataType * localSums)
{
	barrier(CLK_LOCAL_MEM_FENCE);

	for (uint stride = get_local_size(0) / 2; stride > 0; stride /= 2) {

		if (localId < stride) {
			localSums[localId] += localSums[localId + stride];
		}
		barrier(CLK_LOCAL_MEM_FENCE);
	}

	if (localId == 0) {
		partialSums[get_group_id(0)] = localSums[0];
	}
}

static CLNetDataType inline res(CLNetDataType fy, CLNetDataType y)
{
	CLNetDataType r = fy - y;
	return r * r;
}

__kernel void chiSquared(__global const CLNetDataType * restrict fy, __global const CLNetDataType * restrict y,
						 __local CLNetDataType * localSums, __global CLNetDataType * restrict partialSums, uint n)
{
	uint globalId = get_global_id(0);
	uint localId  = get_local_id(0);
	uint index = get_group_id(0) * get_local_size(0) + localId;

	localSums[localId] = (index < n) ? res(fy[globalId], y[globalId]) : 0.0f;
	reduceInline(localId, partialSums, localSums);
}

__kernel void chiSquaredReduce(__global CLNetDataType * restrict partialSums, __local CLNetDataType * localSums)
{
	uint localId  = get_local_id(0);
	localSums[localId] = partialSums[get_global_id(0)];
	reduceInline(localId, partialSums, localSums);
}



//Jacobian
__kernel void jacobian(__global CLNetDataType * restrict jacobian,
					   __global CLNetDataType * restrict inputs,
					   uint columnsG, uint rowsI, uint columnsI, uint offset, uint slope, uint yTimes)
{
	uint x = get_global_id(0);
	uint y = get_global_id(1);

	if (x < columnsI && y < rowsI) {

		for (uint t = 0; t < yTimes; ++t) {

			CLNetDataType value = inputs[y * columnsI + x];

			for (uint i = 0; i < slope; ++i) {
				jacobian[(y + rowsI * t) * columnsG + x * slope + i + offset] = value;
			}
		}
	}
}


//delta
__kernel void delta(__global CLNetDataType * restrict delta, __global CLNetDataType * restrict y, __global CLNetDataType * restrict f,
					__global CLNetDataType * restrict jacobian,
					uint ny, uint npar)
{
	uint x = get_global_id(0);

	if (x < npar) {
		CLNetDataType sum = 0;
		for (uint i = 0; i < ny; ++i) {
			sum += (y[i] - f[i]) * jacobian[i * npar + x];
		}
		delta[x] = sum;
	}
}

#define TOL 1e-30f
#define a(r, c) a[(r * npar + c)]
#define l(r, c) l[(r * npar + c)]

__kernel void choleskyDecomposition(__global CLNetDataType * restrict l,
									CLNetDataType alpha, __global CLNetDataType * restrict a,
									__global CLNetDataType * sums, uint npar, __global uint * ill, uint x)
{
	uint y = get_global_id(0);

	if (y >= npar) {
		return;
	}

	CLNetDataType diag = a(x, x) * alpha - sums[x];

	if (diag < TOL) {
		ill[0] = 1;
		return;
	}

	diag = sqrt(diag);

	if (y > x) {
		CLNetDataType sum = a(x, y);
		for (uint k = 0; k < x; ++k) {
			sum -= l(k, x) * l(k, y);
		}
		sum /= diag;
		l(x, y) = sum;
		sums[y] += sum * sum;
	}

	if (y == x) {
		l(x, x) = diag;
		a(x, x) *= alpha;
	}
}
